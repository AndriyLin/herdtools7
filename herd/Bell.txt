A summary of bell constructs:

* events TYPE[TAGS1,..,TAGSN]

  Define legal instruction (events) annotations where:
   - TYPE is R,W,F or RMW.
   - TAGSi is a set of tags.
  Legal anotations are 'tag1,...,'tagN, where 'tagi in TAGi  
  Definition for the same type cummulate.

  Model execution will take place in an environment where, for each tag
  'name, the variable Name (name with initial letter uppercase)
  is bound to the set of events that have annotation name.

* enum regions = 'tag1 || ... || 'tagN
  Define region names. It is checked that the litmus test uses tag1 ... tagN
  as region names.
  Model execution will take place in an enviroment where, for each tag 'name,
  the variable Name (name with initial letter uppercase) is bound to
  the set of events that act upon a location in region name.

* enum scopes = 'tag1 || ... || 'tagN
  Define scope names, this definition must precede the definitions
  of the narrower or wider functions that define scope hierarchy.

  Model execution will take place in an enviroment where, for each tag 'name,
  the variable name is bound to the equivalence relation that relates
  the events in the same scope of level name.

* let wider(s) = ...
  The wider function defines the scope hierarchy by its parent function that
  associate the tag (of enum scopes) of the parent to the tag of a scope.

* let narrower = ..
  The narrower function defines the scope hierarchy by its children function.
  Notice that narrower may return a set of tags.

  It is possible to define both functions. If so, it is checked
  that they define the same hierachy.


* Scope tree, abbreviated.

  Scope trees can be given in simplified form. In such a form, nodes with one
  child can be left implicit. For instance:

(wg 0 1 2 3)
==>
(system (agent (wg (wave (wi 0)) (wave (wi 1)) (wave (wi 2)) (wave (wi 3)))))

where all nodes but wg are left implicit

Or

(system (wg 0 2) (wg 1 3))
==>
(system
  (agent (wg (wave (wi 0)) (wave (wi 2))))
  (agent (wg (wave (wi 1)) (wave (wi 3)))))

the root scope can also be left implicit, even when it has
several children. That is, the above can be further abreviated as:
(wg 0 2) (wg 1 3)

Another try
(wg 0 2) (agent 1 3)
==>
(system
  (agent (wg (wave (wi 0)) (wave (wi 2))))
  (agent (wg (wave (wi 2))) (wg (wave (wi 3)))))



