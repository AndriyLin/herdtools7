"Relaxed ARM llh model"

include "filters.cat"
(* co with load-load hazards *)

(* co observations in test *)
let invrf = rf^-1

let obsco =
  let ww = po-loc & (W * W)
  and rw = rf ; (po-loc & (R * W))
  and wr = (po-loc & (W * R)) ; invrf
  and rr = 0 in
  (ww|rw|wr|rr) \ id

let RMW = R & W
let rmwco = rf & (W * RMW) (* co observation by atomicity *)

let cobase = obsco|rmwco|co0

(* Catch uniproc violations early *)
acyclic cobase as ConsCo

(* Compute linarisations per locations *)
let rec co_locs wss = match wss with
|| {} -> {}
|| ws ++ wss ->
    linearisations(ws,cobase) ++ co_locs wss   
end

(* Cross product linearisations *)
let cross = 
  let rec do_cross (k,ys,oss) = match oss with
  || {} -> ys ++ k
  || os ++ oss ->
       let rec call_rec (k,os) = match os with
       || {} -> k
       || o ++ os ->
           call_rec (do_cross (k,o | ys,oss),os)
       end in
       call_rec (k,os)
  end in
  fun oss -> do_cross ({},0,oss)

with co from cross (co_locs (partition W))
let coe = co & ext
let coi = co & int
let fr = (invrf ; co) \ id
let fre = fr & ext
let fri = fr & int

show co,fr

(* Uniproc *)
let poi = WW(po-loc) | RW(po-loc) | WR(po-loc)
let complus = fr|rf|co|(co;rf)|(fr;rf)
irreflexive poi;complus as uniproc

(* Utilities *)
let dd = addr | data
let rdw = po-loc & (fre;rfe)
let detour = po-loc & (coe ; rfe)
let addrpo = addr;po
(*******)
(* ppo *)
(*******)


(* Initial value *)
let ci0 = ctrlisync | detour
let ii0 = dd | rfi | rdw
let cc0 = dd | ctrl | addrpo (* po-loc removed *)
let ic0 = 0

include "ppo.cat"

(**********)
(* fences *)
(**********)

(* Power *)
let lwsync = RM(lwsync)|WW(lwsync)
let eieio = WW(eieio)
show sync,lwsync,eieio

(* ARM *)
let dmb.st=WW(dmb.st)
let dsb.st=WW(dsb.st)
show dmb,dsb,dmb.st,dsb.st

(* Common, all arm barriers are strong *)
let strong = sync|dmb|dsb|dmb.st|dsb.st
let light = lwsync|eieio

let fence = strong|light


(* extensions *)
let ppoext = (rfe;ppo)|(ppo;rfe)|(rfe;ppo;rfe)
let fenceext = (rfe;fence)|(fence;rfe)|(rfe;fence;rfe)

(* happens before *)
let hb = ppo | ppoext | fence | fenceext
let GHB = hb
acyclic hb as thinair

(* prop *)
let hbstar = hb*
let propbase = (fence|fenceext);hbstar

let chapo = rfe|fre|coe|(fre;rfe)|(coe;rfe)

let prop = WW(propbase)| (chapo? ; propbase*; strong; hbstar)

acyclic co|prop as propagation
irreflexive fre;prop;hbstar as causality

