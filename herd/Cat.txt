Modification of the cat language

* Predefined sets
  - R -> memory read events
  - W -> memory write events
  - M -> memory events
  - F -> Fence envents
  - I -> initial memory write events

  Depending on architectures
    - Machine architectures: specific fences, uppercase:
        ie SYNC,LWSYNC,EIEIO,ISYNC for Power
           DMB,DSB,DMB.ST,DSB.ST,ISB for ARM
           MFENCE,LFENCE,SFENCE for X86
           SYNC for MIPS

    - C arch, specific sets:
      - "Special events"
        RMW,BRMW (blocked RMW's ?)
        LK (lock), UL (unlock), LS (successful lock ?),
      - Annotations
        - SC,ACQ,REL,ACQ_REL,RLX,CON (according to annotations)
        - A (all atomics), NA (all non-atomics)
           
    - Bell, depending on bell files
        - foreach annotation:
            Annot: all events with annotation annot

   
* Predefined relations
   - id -> identity
   - loc -> events with the same location
   - int -> events on the same proc.
   - ext -> events on different procs.
   - atom -> atomic pairs (ie successful LL/SC pairs)
   - po  -> program order
   - addr,data,ctrl -> dependencies
   - rf -> read-from

   Bell specific
    - for each scope sc (tag 'sc of enum scopes)
       sc -> equivalence relation that
             represents teh dynamic scopes of level sc.

* Primitive functions.
    - partition(<E>)
       * <E> must be to a set of (memory) events.
       * Return a partition {<E1>,...,<En>} according to
         the locations of events
    - classes(<R>)
       * <R> must be to an equivalence relation.
       * Return the set of equivalence classes of <R>.
    - linearisation(<E>,<R>).
       * <E> must be to a set of events and <R> a relation.
       * Return the set of linearisations of the restriction
         of <R> to <E> (ie of (<E>*<E>) & <R>, which must be acyclic).
         In other worlds retirns all totoplogical orders of teh graph
          (<E>*<E>) & <R>.
     - tag2scope(<t>).
       * <t> must be to a tag 'sc of enum scopes (see Bell.txt).
       * Return the (equivalence ) relation sc (computed by herd) that
         represent teh dynamic scopes of level sc.
     - tag2events(<t>).
       * <t> must be to a tag 'annot of some of the enums defined
             in the bell file.
       * Return the set  Annot of events that have the annotation annot,
         as defined by the events construct of the bell file.
      - domain(<R>)
       * <R> must be to a relation.
       * Return the domain of the relation. That is the set
         { e | (_,e) \in <R> }
      - range(<R>)
       * <R> must be a relation.
       * Return the range of the relation. That is the set
         { e | (e,_) \in <R> }
      - fail(<v>)
       * fails (also showing <v> in debug output).

* New instruction with <var> from <expr>
  - evaluates <expr> to a set <S>.
  - Then executes the remainder of the cat file for each element <v> in <S> in
    a context augmented by a binding from <var> to <v>.

Typical Example, to get all sc orders, ie all orders that extend po|com:
   "with o from (linarisations(M,po|com))"
    // Now o is a scheduling order


  - There is a undocumented feature <expr> can be a function.
    In such case the function is called with a specific continuation
    argument. The function sould then be a generator that will
    feed the continuation with <v>. Experimental and thus partially documented.
  
* New instruction "forall <var> in <S> do <INS LIST> end"
   <S> being a set <v1,...,vN>, behave as the expansion of the loop:
   let <var> = <v1>
   <INS LIST>
   ...
   let <var> = <vN>
   <INS LIST>
   Notice that the binding of <var> is discarded in the remainder of model.

* Allow ~testname as a test, the effect is to negate test outcome,
  e.g. ~acyclic is true for cyclic relations.
        
  Hence test syntax now is
   test_name: acyclic|~acyclic|empty|~empty|irreflexive|~irreflexive
   test: expr (as name)?

* New 'flag' construct, test syntax is
   new_test:
   | test --> as before
   | undefined_unless test -> as before
   | flag test ->
      the test must have a name, and this name is execution is
      recorded as having flagged the name, when the test evaluates to true.
      *Notice* as in the  undefined_unless case, flagged tests
      never abort model execution.
        
* New -showflag <string> for herd7

Thus get pictures of say racy execution:
CAT:
let races = ...
flag ~empty races as racy

UNIX:
herd7 ... -showflag racy -gv

* Similar -throughflag <string> select excutions with flag <string>
 will enable approximate comparison of flagged execution by comparing
 flagged outcomes.

* Experimental "when" clause for toplevel let rec
  A toplevel let rec declaration cam be complemented by a
  when [~](acyclic|empty|irreflexive) clause.

  The semantics is as follows: the check is performed at every fixpoint
  iteration step. If the test fails, the execution is interupted, as
  with ordinary checks. The idea is optimisation, consider:

  let rec S =
    ...
  | S;S
  when acyclic S

 is equivalent to

  let rec S =
    ...
  | S;S

  irreflexive S

  but it should be faster (up to test cost), as fixpoint iteration is
  interupted.

* Name procedure calls (call ... [as name]). behave as checks as regard
  skipping.

* New "if e1 = e2 then e3 else e4" expression construct. Semantics is as
  expected. Can be used to build maps as functions.

* Added tuples tuple expressions are () and (e1,...,eN) N >= 2
  Also added bindings for destructuring tuples:
  (x1,..,xN) = e and tuple formal arguments.
  Cannot be nested.
 

